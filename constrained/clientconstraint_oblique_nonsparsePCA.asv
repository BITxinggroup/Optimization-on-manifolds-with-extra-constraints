function clientconstraint_oblique_nonsparsePCA
rng(11);
Dim = 2;
dim = 1;

N_in = 20;
N_out = 10;
Lambda_in = eye(dim);
%     for c = 1 : dim
%         Lambda_in(c,c) = c;
%     end
V = zeros(Dim, dim);
V(1:dim,1:dim) = eye(dim);
Sig_in = V*Lambda_in*V.';
%     Sig_out = randn(Dim);
%     Sig_out = Sig_out.'*Sig_out;
Sig_out = eye(Dim);
X= zeros(N_in+N_out, Dim);
mu = zeros(Dim, 1);
X(1: N_in, :) = mvnrnd(mu, Sig_in, N_in);
X(N_in+1: N_in+N_out, :) = mvnrnd(mu, Sig_out/rank(Sig_out), N_out);
X = X.';

figure
scatter(X(1, :), X(2, :));


manifold = obliquefactory(Dim, dim);
problem.M = manifold;
problem.cost = @(u) costfun(u);
problem.grad = @(u) gradfun(u);

checkgradient(problem);

constraints_cost = cell(1, Dim*dim);
for row = 1: Dim
    for col = 1: dim
        constraints_cost{(col-1)*Dim + row} = @(U) U(row, col);
        

    end
end

constraints_grad = cell(1, 4);
constraints_grad{1} = @(X) [1; 0];
constraints_grad{2} = @(X) [-1; 0];
constraints_grad{3} = @(X) [0; 1];
constraints_grad{4} = @(X) [0; -1];

problem.ineq_constraint_cost = constraints_cost;
problem.ineq_constraint_grad = constraints_grad;
% for i = 1:4
%     newproblem.M = manifold;
%     newproblem.cost = constraints_cost{i};
%     newproblem.grad = constraints_grad{i};
% end

x0 = problem.M.rand();
options = [];
alm(problem, x0, options);

    function val = costfun(u)
        val = .5 * norm(u.' * X, 'fro')^2;
    end

    function val = gradfun(u)
        val = X * (u.' * X).';
    end

end


